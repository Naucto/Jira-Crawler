# Generated by ariadne-codegen

from typing import Any, Dict, Optional

from . import (
    DependencyGraphEcosystem,
    EnterpriseAdministratorRole,
    SearchType,
    SecurityAdvisoryClassification,
    SecurityAdvisoryEcosystem,
    SecurityAdvisorySeverity,
)
from .custom_fields import (
    CodeOfConductFields,
    EnterpriseAdministratorInvitationFields,
    EnterpriseFields,
    EnterpriseMemberInvitationFields,
    GitHubMetadataFields,
    LicenseFields,
    MarketplaceCategoryFields,
    MarketplaceListingConnectionFields,
    MarketplaceListingFields,
    NodeInterface,
    OrganizationFields,
    QueryFields,
    RateLimitFields,
    RepositoryFields,
    RepositoryOwnerInterface,
    SearchResultItemConnectionFields,
    SecurityAdvisoryConnectionFields,
    SecurityAdvisoryFields,
    SecurityVulnerabilityConnectionFields,
    SponsorableItemConnectionFields,
    TopicFields,
    UniformResourceLocatableInterface,
    UserFields,
)
from .custom_typing_fields import GraphQLField
from .input_types import (
    SecurityAdvisoryIdentifierFilter,
    SecurityAdvisoryOrder,
    SecurityVulnerabilityOrder,
    SponsorableOrder,
)


class Query:
    @classmethod
    def code_of_conduct(cls, key: str) -> CodeOfConductFields:
        arguments: Dict[str, Dict[str, Any]] = {
            "key": {"type": "String!", "value": key}
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return CodeOfConductFields(
            field_name="codeOfConduct", arguments=cleared_arguments
        )

    @classmethod
    def codes_of_conduct(cls) -> CodeOfConductFields:
        return CodeOfConductFields(field_name="codesOfConduct")

    @classmethod
    def enterprise(
        cls, slug: str, *, invitation_token: Optional[str] = None
    ) -> EnterpriseFields:
        arguments: Dict[str, Dict[str, Any]] = {
            "invitationToken": {"type": "String", "value": invitation_token},
            "slug": {"type": "String!", "value": slug},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return EnterpriseFields(field_name="enterprise", arguments=cleared_arguments)

    @classmethod
    def enterprise_administrator_invitation(
        cls, enterprise_slug: str, role: EnterpriseAdministratorRole, user_login: str
    ) -> EnterpriseAdministratorInvitationFields:
        arguments: Dict[str, Dict[str, Any]] = {
            "enterpriseSlug": {"type": "String!", "value": enterprise_slug},
            "role": {"type": "EnterpriseAdministratorRole!", "value": role},
            "userLogin": {"type": "String!", "value": user_login},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return EnterpriseAdministratorInvitationFields(
            field_name="enterpriseAdministratorInvitation", arguments=cleared_arguments
        )

    @classmethod
    def enterprise_administrator_invitation_by_token(
        cls, invitation_token: str
    ) -> EnterpriseAdministratorInvitationFields:
        arguments: Dict[str, Dict[str, Any]] = {
            "invitationToken": {"type": "String!", "value": invitation_token}
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return EnterpriseAdministratorInvitationFields(
            field_name="enterpriseAdministratorInvitationByToken",
            arguments=cleared_arguments,
        )

    @classmethod
    def enterprise_member_invitation(
        cls, enterprise_slug: str, user_login: str
    ) -> EnterpriseMemberInvitationFields:
        arguments: Dict[str, Dict[str, Any]] = {
            "enterpriseSlug": {"type": "String!", "value": enterprise_slug},
            "userLogin": {"type": "String!", "value": user_login},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return EnterpriseMemberInvitationFields(
            field_name="enterpriseMemberInvitation", arguments=cleared_arguments
        )

    @classmethod
    def enterprise_member_invitation_by_token(
        cls, invitation_token: str
    ) -> EnterpriseMemberInvitationFields:
        arguments: Dict[str, Dict[str, Any]] = {
            "invitationToken": {"type": "String!", "value": invitation_token}
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return EnterpriseMemberInvitationFields(
            field_name="enterpriseMemberInvitationByToken", arguments=cleared_arguments
        )

    @classmethod
    def id(cls) -> GraphQLField:
        return GraphQLField(field_name="id")

    @classmethod
    def license(cls, key: str) -> LicenseFields:
        arguments: Dict[str, Dict[str, Any]] = {
            "key": {"type": "String!", "value": key}
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return LicenseFields(field_name="license", arguments=cleared_arguments)

    @classmethod
    def licenses(cls) -> LicenseFields:
        return LicenseFields(field_name="licenses")

    @classmethod
    def marketplace_categories(
        cls,
        *,
        exclude_empty: Optional[bool] = None,
        exclude_subcategories: Optional[bool] = None,
        include_categories: Optional[str] = None
    ) -> MarketplaceCategoryFields:
        arguments: Dict[str, Dict[str, Any]] = {
            "excludeEmpty": {"type": "Boolean", "value": exclude_empty},
            "excludeSubcategories": {"type": "Boolean", "value": exclude_subcategories},
            "includeCategories": {"type": "String", "value": include_categories},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return MarketplaceCategoryFields(
            field_name="marketplaceCategories", arguments=cleared_arguments
        )

    @classmethod
    def marketplace_category(
        cls, slug: str, *, use_topic_aliases: Optional[bool] = None
    ) -> MarketplaceCategoryFields:
        arguments: Dict[str, Dict[str, Any]] = {
            "slug": {"type": "String!", "value": slug},
            "useTopicAliases": {"type": "Boolean", "value": use_topic_aliases},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return MarketplaceCategoryFields(
            field_name="marketplaceCategory", arguments=cleared_arguments
        )

    @classmethod
    def marketplace_listing(cls, slug: str) -> MarketplaceListingFields:
        arguments: Dict[str, Dict[str, Any]] = {
            "slug": {"type": "String!", "value": slug}
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return MarketplaceListingFields(
            field_name="marketplaceListing", arguments=cleared_arguments
        )

    @classmethod
    def marketplace_listings(
        cls,
        *,
        admin_id: Optional[str] = None,
        after: Optional[str] = None,
        all_states: Optional[bool] = None,
        before: Optional[str] = None,
        category_slug: Optional[str] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        organization_id: Optional[str] = None,
        primary_category_only: Optional[bool] = None,
        slugs: Optional[str] = None,
        use_topic_aliases: Optional[bool] = None,
        viewer_can_admin: Optional[bool] = None,
        with_free_trials_only: Optional[bool] = None
    ) -> MarketplaceListingConnectionFields:
        arguments: Dict[str, Dict[str, Any]] = {
            "adminId": {"type": "ID", "value": admin_id},
            "after": {"type": "String", "value": after},
            "allStates": {"type": "Boolean", "value": all_states},
            "before": {"type": "String", "value": before},
            "categorySlug": {"type": "String", "value": category_slug},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "organizationId": {"type": "ID", "value": organization_id},
            "primaryCategoryOnly": {"type": "Boolean", "value": primary_category_only},
            "slugs": {"type": "String", "value": slugs},
            "useTopicAliases": {"type": "Boolean", "value": use_topic_aliases},
            "viewerCanAdmin": {"type": "Boolean", "value": viewer_can_admin},
            "withFreeTrialsOnly": {"type": "Boolean", "value": with_free_trials_only},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return MarketplaceListingConnectionFields(
            field_name="marketplaceListings", arguments=cleared_arguments
        )

    @classmethod
    def meta(cls) -> GitHubMetadataFields:
        return GitHubMetadataFields(field_name="meta")

    @classmethod
    def node(cls, id: str) -> NodeInterface:
        arguments: Dict[str, Dict[str, Any]] = {"id": {"type": "ID!", "value": id}}
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return NodeInterface(field_name="node", arguments=cleared_arguments)

    @classmethod
    def nodes(cls, ids: str) -> NodeInterface:
        arguments: Dict[str, Dict[str, Any]] = {"ids": {"type": "ID!", "value": ids}}
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return NodeInterface(field_name="nodes", arguments=cleared_arguments)

    @classmethod
    def organization(cls, login: str) -> OrganizationFields:
        arguments: Dict[str, Dict[str, Any]] = {
            "login": {"type": "String!", "value": login}
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return OrganizationFields(
            field_name="organization", arguments=cleared_arguments
        )

    @classmethod
    def rate_limit(cls, *, dry_run: Optional[bool] = None) -> RateLimitFields:
        arguments: Dict[str, Dict[str, Any]] = {
            "dryRun": {"type": "Boolean", "value": dry_run}
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return RateLimitFields(field_name="rateLimit", arguments=cleared_arguments)

    @classmethod
    def relay(cls) -> QueryFields:
        return QueryFields(field_name="relay")

    @classmethod
    def repository(
        cls, name: str, owner: str, *, follow_renames: Optional[bool] = None
    ) -> RepositoryFields:
        arguments: Dict[str, Dict[str, Any]] = {
            "followRenames": {"type": "Boolean", "value": follow_renames},
            "name": {"type": "String!", "value": name},
            "owner": {"type": "String!", "value": owner},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return RepositoryFields(field_name="repository", arguments=cleared_arguments)

    @classmethod
    def repository_owner(cls, login: str) -> RepositoryOwnerInterface:
        arguments: Dict[str, Dict[str, Any]] = {
            "login": {"type": "String!", "value": login}
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return RepositoryOwnerInterface(
            field_name="repositoryOwner", arguments=cleared_arguments
        )

    @classmethod
    def resource(cls, url: Any) -> UniformResourceLocatableInterface:
        arguments: Dict[str, Dict[str, Any]] = {"url": {"type": "URI!", "value": url}}
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return UniformResourceLocatableInterface(
            field_name="resource", arguments=cleared_arguments
        )

    @classmethod
    def search(
        cls,
        query: str,
        type: SearchType,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        first: Optional[int] = None,
        last: Optional[int] = None
    ) -> SearchResultItemConnectionFields:
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "query": {"type": "String!", "value": query},
            "type": {"type": "SearchType!", "value": type},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return SearchResultItemConnectionFields(
            field_name="search", arguments=cleared_arguments
        )

    @classmethod
    def security_advisories(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        classifications: Optional[SecurityAdvisoryClassification] = None,
        epss_percentage: Optional[float] = None,
        epss_percentile: Optional[float] = None,
        first: Optional[int] = None,
        identifier: Optional[SecurityAdvisoryIdentifierFilter] = None,
        last: Optional[int] = None,
        order_by: Optional[SecurityAdvisoryOrder] = None,
        published_since: Optional[Any] = None,
        updated_since: Optional[Any] = None
    ) -> SecurityAdvisoryConnectionFields:
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "classifications": {
                "type": "SecurityAdvisoryClassification",
                "value": classifications,
            },
            "epssPercentage": {"type": "Float", "value": epss_percentage},
            "epssPercentile": {"type": "Float", "value": epss_percentile},
            "first": {"type": "Int", "value": first},
            "identifier": {
                "type": "SecurityAdvisoryIdentifierFilter",
                "value": identifier,
            },
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "SecurityAdvisoryOrder", "value": order_by},
            "publishedSince": {"type": "DateTime", "value": published_since},
            "updatedSince": {"type": "DateTime", "value": updated_since},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return SecurityAdvisoryConnectionFields(
            field_name="securityAdvisories", arguments=cleared_arguments
        )

    @classmethod
    def security_advisory(cls, ghsa_id: str) -> SecurityAdvisoryFields:
        arguments: Dict[str, Dict[str, Any]] = {
            "ghsaId": {"type": "String!", "value": ghsa_id}
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return SecurityAdvisoryFields(
            field_name="securityAdvisory", arguments=cleared_arguments
        )

    @classmethod
    def security_vulnerabilities(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        classifications: Optional[SecurityAdvisoryClassification] = None,
        ecosystem: Optional[SecurityAdvisoryEcosystem] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        order_by: Optional[SecurityVulnerabilityOrder] = None,
        package: Optional[str] = None,
        severities: Optional[SecurityAdvisorySeverity] = None
    ) -> SecurityVulnerabilityConnectionFields:
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "classifications": {
                "type": "SecurityAdvisoryClassification",
                "value": classifications,
            },
            "ecosystem": {"type": "SecurityAdvisoryEcosystem", "value": ecosystem},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "orderBy": {"type": "SecurityVulnerabilityOrder", "value": order_by},
            "package": {"type": "String", "value": package},
            "severities": {"type": "SecurityAdvisorySeverity", "value": severities},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return SecurityVulnerabilityConnectionFields(
            field_name="securityVulnerabilities", arguments=cleared_arguments
        )

    @classmethod
    def sponsorables(
        cls,
        *,
        after: Optional[str] = None,
        before: Optional[str] = None,
        dependency_ecosystem: Optional[SecurityAdvisoryEcosystem] = None,
        ecosystem: Optional[DependencyGraphEcosystem] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        only_dependencies: Optional[bool] = None,
        order_by: Optional[SponsorableOrder] = None,
        org_login_for_dependencies: Optional[str] = None
    ) -> SponsorableItemConnectionFields:
        arguments: Dict[str, Dict[str, Any]] = {
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "dependencyEcosystem": {
                "type": "SecurityAdvisoryEcosystem",
                "value": dependency_ecosystem,
            },
            "ecosystem": {"type": "DependencyGraphEcosystem", "value": ecosystem},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "onlyDependencies": {"type": "Boolean", "value": only_dependencies},
            "orderBy": {"type": "SponsorableOrder", "value": order_by},
            "orgLoginForDependencies": {
                "type": "String",
                "value": org_login_for_dependencies,
            },
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return SponsorableItemConnectionFields(
            field_name="sponsorables", arguments=cleared_arguments
        )

    @classmethod
    def topic(cls, name: str) -> TopicFields:
        arguments: Dict[str, Dict[str, Any]] = {
            "name": {"type": "String!", "value": name}
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return TopicFields(field_name="topic", arguments=cleared_arguments)

    @classmethod
    def user(cls, login: str) -> UserFields:
        arguments: Dict[str, Dict[str, Any]] = {
            "login": {"type": "String!", "value": login}
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return UserFields(field_name="user", arguments=cleared_arguments)

    @classmethod
    def viewer(cls) -> UserFields:
        return UserFields(field_name="viewer")
